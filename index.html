<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Market Map</title>

  <link rel="stylesheet" href="style.css">
 
</head>
<body>

  <header>
    <img src="Media/Screenshot 2025-08-14 105531.png" alt="Adelaide Central Market Logo">
  </header>

   <!-- Search -->
  <div id="search-wrapper">
    <input type="text" id="search-input" placeholder="Search for a stall..." />
    <div id="search-dropdown"></div>
  </div>


  <!-- Tag Filter Buttons -->
  <div id="tag-buttons">
    <button data-tag="Meat, Poultry & Seafood">Meat, Poultry & Seafood</button>
    <button data-tag="Bakeries & Patisserie">Bakeries & Patisserie</button>
    <button data-tag="Gluten Free">Gluten Free</button>
    <button data-tag="Cafes & Eateries">Cafes & Eateries</button>
    <button data-tag="Continental & Cheese">Continental & Cheese</button>
    <button data-tag="Specialty Food">Specialty Food</button>
    <button data-tag="Fruit & Veg">Fruit & Veg</button>
    <button data-tag="Non-Produce">Non-Produce</button>
    <button data-tag="Nuts Confectionery & Coffee">Nuts Confectionery & Coffee</button>
    <button data-tag="Pop-Up">Pop-Up</button>
    <button data-tag="Utilities">Utilities</button>
  </div>

 
  <div id="map-wrapper">
    <div id="map-container"></div>
  </div>

  <div id="info-box">
    <button id="close-btn" class="close-btn">âœ–</button>
    <h2 id="stall-name"></h2>
    <img id="stall-thumbnail" src="" alt="Stall Thumbnail" loading="lazy" />
    <h3>Opening Hours:</h3>
    <p id="stall-info"></p>
    <a id="stall-url" href="" target="_blank" rel="noopener noreferrer">Visit Store</a>
  </div>



 



<script>
const mapWrapper = document.getElementById('map-wrapper');
const mapContainer = document.getElementById('map-container');
const infoBox = document.getElementById('info-box');
const stallNameEl = document.getElementById('stall-name');
const stallTagsEl = document.getElementById('stall-tags');
const closeBtn = document.getElementById('close-btn');
const tagButtons = document.querySelectorAll('#tag-buttons button');
const searchInput = document.getElementById('search-input');
const searchDropdown = document.getElementById('search-dropdown');


// NEW elements inside info box

const stallInfoEl = document.getElementById('stall-info');
const stallThumbEl = document.getElementById('stall-thumbnail');
const stallBtnEl = document.getElementById('stall-url');

if (stallInfoEl) stallInfoEl.style.whiteSpace = 'pre-line'; // preserve line breaks

let isPanning = false;
let isDragging = false;
let dragThreshold = 5;
let dragStartX = 0;
let dragStartY = 0;
let startX = 0;
let startY = 0;
let translateX = 0;
let translateY = 0;
let scale = 1;
let lastDistance = null;

let stalls = [];
let stallElements = [];
let stallDataGlobal = {}; // store JSON globally

function updateTransform() {
  mapContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
}

// --- Mouse Pan ---
mapWrapper.addEventListener('mousedown', e => {
  isPanning = true;
  isDragging = false;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  startX = translateX;
  startY = translateY;
  mapWrapper.style.cursor = 'grabbing';
});

mapWrapper.addEventListener('mousemove', e => {
  if (!isPanning) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;

  if (!isDragging && Math.sqrt(dx*dx + dy*dy) > dragThreshold) isDragging = true;

  if (isDragging) {
    translateX = startX + dx;
    translateY = startY + dy;
    updateTransform();
  }
});

mapWrapper.addEventListener('mouseup', () => {
  isPanning = false;
  isDragging = false;
  mapWrapper.style.cursor = 'grab';
});

mapWrapper.addEventListener('mouseleave', () => {
  isPanning = false;
  isDragging = false;
  mapWrapper.style.cursor = 'grab';
});

// --- Mouse Wheel Zoom ---
mapWrapper.addEventListener('wheel', e => {
  // Only prevent default if mouse is over the map container
  const rect = mapWrapper.getBoundingClientRect();
  if (
    e.clientX >= rect.left &&
    e.clientX <= rect.right &&
    e.clientY >= rect.top &&
    e.clientY <= rect.bottom
  ) {
    e.preventDefault();

    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    const scaleAmount = -e.deltaY * 0.001;
    const newScale = Math.min(Math.max(0.5, scale + scaleAmount), 3);

    translateX -= (offsetX - translateX) * (newScale / scale - 1);
    translateY -= (offsetY - translateY) * (newScale / scale - 1);

    scale = newScale;
    updateTransform();
  }
});

// --- Touch Pan & Pinch Zoom ---
mapWrapper.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    isPanning = true;
    isDragging = false;
    dragStartX = e.touches[0].clientX;
    dragStartY = e.touches[0].clientY;
    startX = translateX;
    startY = translateY;
  } else if (e.touches.length === 2) {
    isPanning = false;
    lastDistance = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
  }
});

mapWrapper.addEventListener('touchmove', e => {
  if (e.touches.length === 1 && isPanning) {
    const dx = e.touches[0].clientX - dragStartX;
    const dy = e.touches[0].clientY - dragStartY;

    if (!isDragging && Math.sqrt(dx*dx + dy*dy) > dragThreshold) isDragging = true;

    if (isDragging) {
      translateX = startX + dx;
      translateY = startY + dy;
      updateTransform();
    }
  } else if (e.touches.length === 2) {
    const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    const distance = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );

    if (lastDistance) {
      const zoom = distance / lastDistance;
      const newScale = Math.min(Math.max(0.5, scale * zoom), 3);
      translateX -= (midX - translateX) * (newScale / scale - 1);
      translateY -= (midY - translateY) * (newScale / scale - 1);
      scale = newScale;
      updateTransform();
    }
    lastDistance = distance;
  }
});

mapWrapper.addEventListener('touchend', e => {
  if (e.touches.length < 2) lastDistance = null;
  if (e.touches.length === 0) isPanning = false;
  isDragging = false;
});

// --- Load SVG & JSON ---
Promise.all([
  fetch('./Asset 10.svg').then(r => r.text()),
  fetch('./stalls.json').then(r => r.json())
])
.then(([svgText, stallData]) => {
  mapContainer.innerHTML = svgText;
  stallDataGlobal = stallData;

  Object.keys(stallData).forEach(stallId => {
    const stallEl = document.getElementById(stallId);
    if (stallEl) {
      stallEl.classList.add('stall');
      stallEl.dataset.name = stallData[stallId].name;
      stallEl.dataset.tags = stallData[stallId].tags.join(',');
    }
  });

  stalls = mapContainer.querySelectorAll('.stall');
  stallElements = Array.from(stalls);

  // --- Highlight single stall ---
  stalls.forEach(stall => {
    stall.addEventListener('click', e => {
      if (!isDragging) highlightStall(stall.id);
    });
  });

  // --- Close info box ---
  closeBtn.addEventListener('click', () => {
    infoBox.classList.remove('active');
    stalls.forEach(s => {
      s.style.filter = 'none';
      const shape = s.querySelector('rect, path, polygon, circle, ellipse, polyline');
      if (shape) {
        shape.style.stroke = 'none';
        shape.style.strokeWidth = '0';
      }
    });
  });

  // --- Tag buttons ---
  tagButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const tag = btn.dataset.tag.toLowerCase();
      stalls.forEach(s => {
        const stallTags = (s.dataset.tags || '').toLowerCase();
        s.style.filter = stallTags.includes(tag) ? 'none' : 'grayscale(100%) opacity(30%)';

        const shape = s.querySelector('rect, path, polygon, circle, ellipse, polyline');
        if (shape) {
          shape.style.stroke = 'none';
          shape.style.strokeWidth = '0';
        }
      });
    });
  });

  // --- Search ---
  searchInput.addEventListener('input', () => {
    const query = searchInput.value.toLowerCase();
    searchDropdown.innerHTML = '';
    if (!query) return searchDropdown.style.display = 'none';

    const matches = stallElements.filter(s => s.dataset.name.toLowerCase().includes(query));
    if (!matches.length) return searchDropdown.style.display = 'none';

    matches.forEach(s => {
      const div = document.createElement('div');
      div.textContent = s.dataset.name;
      div.addEventListener('click', () => {
        highlightStall(s.id);
        searchDropdown.style.display = 'none';
        searchInput.value = s.dataset.name;
      });
      searchDropdown.appendChild(div);
    });
    searchDropdown.style.display = 'block';
  });

  document.addEventListener('click', e => {
    if (!searchInput.contains(e.target) && !searchDropdown.contains(e.target)) {
      searchDropdown.style.display = 'none';
    }
  });

  // --- Highlight stall function ---
  function highlightStall(stallId) {
    const stallEl = document.getElementById(stallId);
    if (!stallEl) return;

    // Reset all stalls
    stalls.forEach(s => {
      s.style.filter = 'grayscale(100%) opacity(30%)';
      const shape = s.querySelector('rect, path, polygon, circle, ellipse, polyline');
      if (shape) {
        shape.style.stroke = 'none';
        shape.style.strokeWidth = '0';
      }
    });

    // Highlight selected stall
    stallEl.style.filter = 'none';
    const shape = stallEl.querySelector('rect, path, polygon, circle, ellipse, polyline');
    if (shape) {
      shape.style.stroke = '#a4634e';
      shape.style.strokeWidth = '3';
    }

    const data = stallDataGlobal[stallId] || {};

    // Update info box
    if (stallNameEl) stallNameEl.textContent = data.name || '';
    if (stallTagsEl) stallTagsEl.textContent = data.tags ? 'Tags: ' + data.tags.join(', ') : 'No tags available.';
    if (stallThumbEl) {
      stallThumbEl.src = data.thumbnail || '';
      stallThumbEl.style.display = data.thumbnail ? 'block' : 'none';
    }
    if (stallInfoEl) stallInfoEl.textContent = data.info || '';
    if (stallBtnEl) {
      stallBtnEl.href = data.url || '#';
      stallBtnEl.style.display = data.url ? 'inline-block' : 'none';
    }

    if (infoBox) infoBox.classList.add('active');
  }

})
.catch(err => {
  console.error('Error loading SVG or JSON:', err);
  mapContainer.innerHTML = '<div style="color:red; font-size:1.2em; padding:20px;">Sorry, the market map could not be loaded. Please try again later.</div>';
});
</script>



</body>
</html>

